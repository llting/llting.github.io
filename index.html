<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/设计模式读书笔记(十二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/设计模式读书笔记(十二)/" itemprop="url">设计模式读书笔记(十二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-22T22:26:20+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="通信卫星–观察者模式"><a href="#通信卫星–观察者模式" class="headerlink" title="通信卫星–观察者模式"></a>通信卫星–观察者模式</h3><p>观察者模式： 定义了一种依赖关系，解决了主体对象与观察者之间的耦合。</p>
<h4 id="卫星的故事"><a href="#卫星的故事" class="headerlink" title="卫星的故事"></a>卫星的故事</h4><pre><code>目前每个国家都在研发并发射卫星，那么发射卫星有什么作用呢？
</code></pre><p>是为了监控气象卫星，监控城市信息等等。那么这一个监控系统就可以称作一个观察者模式或者消息系统。如果让这颗卫星为飞机导航，那么这架飞机就是一个被观察者对象或者主体对象。当然，主体对象是可以变化的，比如飞机飞翔，就像需求中的消息一样，消息的内容每时每刻都可能变化。因此飞机经常发出位置消息，比如从沈阳到香港，途中经过北京，那么当经过北京上空时，会向卫星发射一则消息来指明自己的位置。卫星接受这些消息后，就能确认这架飞机的具体位置。卫星接收到这些消息并不是最终的目的，最终的目的是要通知地面中转站。地面中转站知道了消息后，会根据消息的不同，对消息进行处理。</p>
<pre><code>于是，卫星，飞机，地面中转站的模型就可以简化成这样， 地面中转站想要知道飞机的情况，就在卫星上先注册这架飞机，飞机每到达一个地方，就把所在的位置信息发送给卫星，卫星接收到后，就通知地面中转站飞机的位置，然后地面中转站就进行相应的处理。
</code></pre><h4 id="创建一个观察者"><a href="#创建一个观察者" class="headerlink" title="创建一个观察者"></a>创建一个观察者</h4><p>把观察者或者消息系统当做一个对象，这个对象包括的方法目前来看，第一个是接收消息，第二个是向订阅该消息的对象发送相应的消息。<br>然后，既然能够接收消息，当飞机到达了终点站时，这就不需要再监控，这就进行了注销，所以第三个是取消注册的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 将观察者放在闭包中， 当页面加载就立即执行</span><br><span class="line">var Observer = (function()&#123;</span><br><span class="line">	// 防止消息队列暴露，而被外部变量获取到私自更改，故将消息容器作为静态私有变量保存</span><br><span class="line">	var _message = &#123;&#125;;</span><br><span class="line">	return &#123;</span><br><span class="line">		// 注册消息接口</span><br><span class="line">		regist : function()&#123;&#125;,</span><br><span class="line">		// 发布消息接口</span><br><span class="line">		fire: function()&#123;&#125;,</span><br><span class="line">		// 移除消息接口</span><br><span class="line">		remove: function()&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>好了，观察者对象的雏形出来了，我们剩下需要做的事情就是一一来实现这三个方法。<br>首先实现注册消息接口的方法， 注册方法的作用是将订阅者（地面中转站）注册的消息推入到消息队列中，因此我们需要接受2个参数：消息类型以及相应的处理动作，在推入到消息队列时如果此消息不存在则应该创建一个该消息类型并将 该消息放入队列中，如果已经存在则应该将该消息执行方法推入该消息执行的方法队列中，这么做的目的也是保证多个模块注册同一则消息能顺利执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 将观察者放在闭包中， 当页面加载就立即执行</span><br><span class="line">var Observer = (function()&#123;</span><br><span class="line">	// 防止消息队列暴露，而被外部变量获取到私自更改，故将消息容器作为静态私有变量保存</span><br><span class="line">	var _message = &#123;&#125;;</span><br><span class="line">	return &#123;</span><br><span class="line">		// 注册消息接口</span><br><span class="line">		regist : function(type, fn)&#123;</span><br><span class="line">			(_message[type] = _message[type] || []).push(fn)</span><br><span class="line">		&#125;,</span><br><span class="line">		// 发布消息接口</span><br><span class="line">		fire: function()&#123;&#125;,</span><br><span class="line">		// 移除消息接口</span><br><span class="line">		remove: function()&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>对于发布消息方法，其功能是当观察者发布一个消息时将所有订阅者订阅的消息一次执行。接收2个参数，消息类型以及动作执行时需要传递的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 将观察者放在闭包中， 当页面加载就立即执行</span><br><span class="line">var Observer = (function()&#123;</span><br><span class="line">	// 防止消息队列暴露，而被外部变量获取到私自更改，故将消息容器作为静态私有变量保存</span><br><span class="line">	var _message = &#123;&#125;;</span><br><span class="line">	return &#123;</span><br><span class="line">		// 注册消息接口</span><br><span class="line">		regist : function(type, fn)&#123;</span><br><span class="line">			(_message[type] = _message[type] || []).push(fn)</span><br><span class="line">		&#125;,</span><br><span class="line">		// 发布消息接口</span><br><span class="line">		fire: function(type，args)&#123;</span><br><span class="line">			(_message[type] = _message[type] || []）.forEach(function(fn)&#123;</span><br><span class="line">				fn.call(this,args || &#123;&#125;)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		// 移除消息接口</span><br><span class="line">		remove: function()&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>最后的就是将消息清楚的办法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 将观察者放在闭包中， 当页面加载就立即执行</span><br><span class="line">var Observer = (function()&#123;</span><br><span class="line">	// 防止消息队列暴露，而被外部变量获取到私自更改，故将消息容器作为静态私有变量保存</span><br><span class="line">	var _message = &#123;&#125;;</span><br><span class="line">	return &#123;</span><br><span class="line">		// 注册消息接口</span><br><span class="line">		regist : function(type, fn)&#123;</span><br><span class="line">			(_message[type] = _message[type] || []).push(fn)</span><br><span class="line">		&#125;,</span><br><span class="line">		// 发布消息接口</span><br><span class="line">		fire: function(type，args)&#123;</span><br><span class="line">			(_message[type] || []).forEach(function(fn)&#123;</span><br><span class="line">				fn.call(this,args || &#123;&#125;)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		// 移除消息接口</span><br><span class="line">		remove: function(type,fn)&#123;</span><br><span class="line">			_message[type] = (_message[type] || []）.filter(function(item)&#123;</span><br><span class="line">				return item !== fn</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>观察者模式最主要的作用是解决类或者对象之间的耦合，解耦两个相互依赖的对象，使其依赖于观察者的消息机制。这样对于任意一个订阅者来说，其他订阅者的变动不会影响到自身。对于每一个订阅者来说，其自身既可以是消息的发出者也可以是消息的订阅者，这都依赖于调用观察者对象的三种方法（注册消息，发出消息，移除消息）中的哪一个。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/设计模式读书笔记(十一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/设计模式读书笔记(十一)/" itemprop="url">设计模式读书笔记(十一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-20T13:41:43+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="照猫画虎–模板方法模式"><a href="#照猫画虎–模板方法模式" class="headerlink" title="照猫画虎–模板方法模式"></a>照猫画虎–模板方法模式</h3><p>模板方法模式： 父类中定义一组操作算法的骨架，实现延迟到子类中，使得子类可以不改变父类的算法结构同时可重新定义算法中某些实现步骤。</p>
<h4 id="提示框的归一化"><a href="#提示框的归一化" class="headerlink" title="提示框的归一化"></a>提示框的归一化</h4><p>页面中有很多弹框，类型包括基本弹出框、包含标题弹出框、左侧确定按钮弹出框、右侧确定按钮弹出框、带有取消按钮弹出框，以及右侧取消按钮弹出框，这么多的弹框要统一样式，是需要一个一个页面修改吗？其实大可不必，这里就用到了模板方法模式。</p>
<p>模板方法模式就是将多个模型抽象化归一，从中提取出来一个最基本的模板，这个模板可以作为实体对象也可以作为抽象对象，然后其他需求对象可以继承这个模板方法，也可以自己拓展方法。</p>
<h4 id="美味的蛋糕"><a href="#美味的蛋糕" class="headerlink" title="美味的蛋糕"></a>美味的蛋糕</h4><p>打个比方，比如我们生活中用蛋糕模具做蛋糕，做出的蛋糕外形是相同的，因为他们都是用了同一个模具，这是最基本的蛋糕。当然我们看到商店里卖的五花八门，有的抹奶油的，有的是水果的，这都是对蛋糕的二次加工，也就是说顾客对蛋糕有不同的需求，所以为了满足不同需求，我们需要添加美味的作料。类似的，我们的解决方案中提到的基本提示框应该就是我们要抽象出来的，因为它是一个最简单的提示框，其他提示框都比这个提示框多一些功能，也就是添加不同的“作料”来满足不同的用户需求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 模板类 基础提示框data渲染数据</span><br><span class="line">var Alert = function(data) &#123;</span><br><span class="line">	if(!data) return;</span><br><span class="line">	this.content = data.content;</span><br><span class="line">	// 创建提示框面板</span><br><span class="line">	this.panpel = doucment.createElement(&apos;div&apos;);</span><br><span class="line"> 	// 创建提示内容组件</span><br><span class="line">	this.contentNode = document.createElement(&apos;p&apos;);</span><br><span class="line">	// 创建确定按钮组件</span><br><span class="line">	this.confirmBtn = document.createElement(&apos;span&apos;);</span><br><span class="line">	// 创建关闭按钮组件</span><br><span class="line">	this.closeBtn = document.createElement(&apos;b&apos;);</span><br><span class="line">	// 为提示框面板添加类</span><br><span class="line">	this.panpel.className = &apos;Alert&apos;;</span><br><span class="line">	// 为关闭按钮添加类</span><br><span class="line">	this.closeBtn.className = &apos;a-close&apos;;</span><br><span class="line">	// 为确定按钮添加类</span><br><span class="line">	this.confirmBtn.className = &apos;a-confirm&apos;;</span><br><span class="line">	// 为确定按钮添加文案</span><br><span class="line">	this.confirmBtn.innerHTML =  data.confirm || &apos;确认&apos;;</span><br><span class="line">	// 为提示内容添加文本</span><br><span class="line">	this.contentNode.innerHTML = this.content;</span><br><span class="line">	// 点击确定按钮执行方法 如果data有 success 方法 就执行 success 方法， 否则为空函数</span><br><span class="line">	this.success = data.success || function()&#123;&#125;;</span><br><span class="line">	// 点击关闭按钮执行方法</span><br><span class="line">	this.fail = data.fail || function()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模板的原型方法"><a href="#模板的原型方法" class="headerlink" title="模板的原型方法"></a>模板的原型方法</h4><p>既然这个基本提示框可创建，那么它也应该有一些基本方法，比如有init方法来组装提示框，bindEvent 方法来绑定点击按钮的相应事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Alert.prototype = &#123;</span><br><span class="line">	init: finction() &#123;</span><br><span class="line">		// 生成提示框</span><br><span class="line">		this.panel.appendChild(this.closeBtn);</span><br><span class="line">		this.panel.appendChild(this.contentNode);</span><br><span class="line">		this.panel.appendChild(this.confirmBtn);</span><br><span class="line">		// 插入页面中	</span><br><span class="line">		document.body.append(this.panel);</span><br><span class="line">		this.bindEvent();</span><br><span class="line">		this.show();</span><br><span class="line">	&#125;,</span><br><span class="line">	bindEvent()&#123;</span><br><span class="line">		var _self = this</span><br><span class="line">		this.closeBtn.onclick = function() &#123;</span><br><span class="line">			_self.fail();</span><br><span class="line">			_self.hide();</span><br><span class="line">		&#125;;</span><br><span class="line">		// 确定按钮点击事件</span><br><span class="line">		this.confirmBtn.onclick = function() &#123;</span><br><span class="line">			_self.success();</span><br><span class="line">			_self.hide()</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;,</span><br><span class="line">	hide: function() &#123;</span><br><span class="line">		this.panel.style.display = &apos;none&apos;;</span><br><span class="line">	&#125;,</span><br><span class="line">	show: function() &#123;</span><br><span class="line">		this.panel.style.display = &apos;block&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了这个基础模板，在想创建其他模板就容易多了，比如右侧按钮弹框。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var RightAlert = function(data) &#123;</span><br><span class="line">	Alert.call(this,data)</span><br><span class="line">	this.confirmBtn.className = this.confirmBtn.className = this.confirmBtn.className + &apos;right&apos;;</span><br><span class="line">&#125;</span><br><span class="line">RightAlert.prototype = new Alert();</span><br></pre></td></tr></table></figure></p>
<h4 id="继承类也可作为模板类"><a href="#继承类也可作为模板类" class="headerlink" title="继承类也可作为模板类"></a>继承类也可作为模板类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var CancelAlert = function(data) &#123;</span><br><span class="line">	RightAlert.call(this,data);</span><br><span class="line">	this.cancel = data.cancel;</span><br><span class="line">	this.cancelBtn.className = &apos;cancel&apos;;</span><br><span class="line">	this.cancelBtn.innerHTML = this.cancel || &apos;取消&apos;</span><br><span class="line">&#125;</span><br><span class="line">CancelAlert.prototype = new Alert()</span><br><span class="line">CancelAlert.prototype.init = function() &#123;</span><br><span class="line">	RightAlert.prototype.init.call(this);</span><br><span class="line">	this.panel.appendChild(this.cancelBtn)</span><br><span class="line">&#125;;</span><br><span class="line">CancelAlert.prototype.bindEvent = function()&#123;</span><br><span class="line">	var _self = this;</span><br><span class="line">	RightAlert.prototype.bindEvent.call(_self);</span><br><span class="line">	this.cancelBtn.onclick = function()&#123;</span><br><span class="line">		_self.fail();</span><br><span class="line">		_self.hide();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>模板方法的核心在于对方法的重用，它将核心方法封装在基类中，让子类继承基类的方法，实现基类方法共享，达到方法共有。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/13/设计模式读书笔记(十)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/设计模式读书笔记(十)/" itemprop="url">设计模式读书笔记(十)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-13T23:17:05+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="城市公交车–享元模式"><a href="#城市公交车–享元模式" class="headerlink" title="城市公交车–享元模式"></a>城市公交车–享元模式</h3><p>享元模式： 运用共享技术有效地支持大量的细粒度对象，避免对象间拥有相同内容造成多余的开销。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var dom = null, // 创建缓存的新闻标题元素</span><br><span class="line">    paper = 0, // 当前页数</span><br><span class="line">    num = 5 , // 每页显示新闻数目</span><br><span class="line">    i = 0, //创建新闻元素时保存变量</span><br><span class="line">    len =article.length // 新闻数据长度</span><br><span class="line"></span><br><span class="line">    for(;i &lt; len ; i++)&#123;</span><br><span class="line">      dom = document.createElement(&apos;div&apos;) // 创建包装新闻标题元素</span><br><span class="line">      dom.innerHTML = atricle[i]</span><br><span class="line">      if(i &gt;= num)&#123;</span><br><span class="line">        dom.style.display = &apos;none&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      document.getElementById(&apos;container&apos;).appendChild(dom) // 添加到页面中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 下一页绑定事件</span><br><span class="line">    document.getElementById(&apos;next_page&apos;).onclick = function()&#123;</span><br><span class="line">      var div = document.getElementById(&apos;container&apos;).getElementByTagName(&apos;div&apos;),</span><br><span class="line">      j = k = n = 0;</span><br><span class="line">      n = ++pager % Math.ceil(len / num) * num</span><br><span class="line">      for(; j &lt; len;j++)&#123;</span><br><span class="line">        div[j].style.dispaly = &apos;none&apos; // 隐藏所有新闻</span><br><span class="line">      &#125;</span><br><span class="line">      for(;k &lt; 5,k++)&#123;</span><br><span class="line">        if(div[n + k])&#123;</span><br><span class="line">          div[n + k].style.display = &apos;block&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个代码的思路是页面加载后，异步请求新闻数据，然后创建所有条新闻并插入页面中，需要显示那一页就将对应页的新闻显示，其他隐藏</p>
<h4 id="冗余的结构"><a href="#冗余的结构" class="headerlink" title="冗余的结构"></a>冗余的结构</h4><p>问题就出在这里了，所有的新闻都有同样的结构，只是内容不同罢了，创建了几百条新闻都插入到页面中了并操作造成的多余开销，会导致性能下降，这里就可以用享元模式来解决了。</p>
<p>享元模式主要对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法、外部数据、外部方法。 内部数据与内部方法指的是相似或者共有的数据与方法，所以将这一部分提取出来减少开销，以提高性能。</p>
<h4 id="享元对象"><a href="#享元对象" class="headerlink" title="享元对象"></a>享元对象</h4><p>上面的代码都有共同的结构，所以它们应该作为内部的数据，而‘下一页’按钮绑定的事件已经不能再提取抽象了，所以就是外部方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">var Flyweight = function()&#123;</span><br><span class="line">  // 已创建的元素</span><br><span class="line">  var created = []</span><br><span class="line">  // 创建一个新闻包装容器</span><br><span class="line">  function create()&#123;</span><br><span class="line">    var dom = document.createElement(&apos;div&apos;)</span><br><span class="line">    // 讲容器插入新闻列表容器</span><br><span class="line">    document.getElementById(&apos;container&apos;).appendChild(dom)</span><br><span class="line">    // 缓存新创建的元素</span><br><span class="line">    created.push(dom)</span><br><span class="line">    return dom</span><br><span class="line">  &#125; </span><br><span class="line">  return &#123;</span><br><span class="line">    getDiv:function()&#123;</span><br><span class="line">      if(created.length &lt; 5)&#123;</span><br><span class="line">        return create()</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        var div = created.shift()</span><br><span class="line">        created.push(div)</span><br><span class="line">        return div</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var paper = 0,</span><br><span class="line">    num = 5,</span><br><span class="line">    i = 0, //创建新闻元素时保存变量</span><br><span class="line">    len =article.length // 新闻数据长度</span><br><span class="line"></span><br><span class="line">    for(;i &lt; 5 ; i++)&#123;</span><br><span class="line">      if(article[i])&#123;</span><br><span class="line">        Flyweight.getDiv().innerHTML = article[i]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&apos;next_page&apos;).onclick = function()&#123;</span><br><span class="line">      if(article.length &lt; 5&gt;)&#123;</span><br><span class="line">        return </span><br><span class="line">      &#125;</span><br><span class="line">      var n = ++pager * num % len;</span><br><span class="line">      for(var j = 0 ;j &lt; 5; j++)&#123;</span><br><span class="line">        if(article[n + j])&#123;</span><br><span class="line">          // 存在n + j 就插入</span><br><span class="line">            Flyweight.getDiv().innerHTML = article[n + j]</span><br><span class="line">          // 否则插入起始位置第 n + j - len 条</span><br><span class="line">        &#125;else if(article[n + j - len])&#123;</span><br><span class="line">             Flyweight.getDiv().innerHTML = article[n + j]</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">          // 不存在就插入空</span><br><span class="line">             Flyweight.getDiv().innerHTML = &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>享元模式的应用是为了提高程序的执行效率与系统的性能，应用时需要找准内部方法数据与外部方法数据，这样才能进行合理的区分。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/设计模式读书笔记(九)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/设计模式读书笔记(九)/" itemprop="url">设计模式读书笔记(九)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-07T23:27:19+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="超值午餐-–-组合模式"><a href="#超值午餐-–-组合模式" class="headerlink" title="超值午餐 – 组合模式"></a>超值午餐 – 组合模式</h3><p>组合模式: 又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>场景如下：<br>“新闻模块加一条文字新闻”<br>“新闻模块加一条带有直播图标的文字新闻”<br>“新闻模块加一条已分类的文字新闻”<br>“新闻模块加一条图片新闻”<br>“将图片新闻和文字新闻放在一行”</p>
<p>我们发现，需求中的这些新闻大致可以分为相互独立的几种类型，而对某类新闻做修改时，又不会影响到其他类新闻，这样完全可以将每一类新闻抽象成面向对象编程中的一个类，这样就不会担心日后对某类新闻需求更改而影响到其他类新闻，只需要针对于这些新闻类做出更改即可，如果要完成经理提出的需求，仅需要针对这些新闻中挑选一些组合起来。先将新闻模块整体拆分成个体来对待，然后需要时，将这些不同的个体组合起来即可。</p>
<h4 id="餐厅里的套餐业务"><a href="#餐厅里的套餐业务" class="headerlink" title="餐厅里的套餐业务"></a>餐厅里的套餐业务</h4><p>举个例子，比如我们中午吃饭，我们一个一个的点的话，很浪费时间，但提供套餐组合的话，我们只需要提供套餐的名字即可，这样又节省时间，餐厅也更加快速响应，虽然餐厅提供了套餐的名字，但是他们在制作的时候，仍然是一个一个制作出来的，每一部分都是独立的个体，而提供给我们的，就是这些个体的组合，最终可以给我们复杂的套餐。</p>
<p>对于使用组合模式而言，有一个唯一的要求就是需要接口命名的统一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var News = function()&#123;</span><br><span class="line">  // 子容器</span><br><span class="line">  this.children = []</span><br><span class="line">  // 当前组件元素</span><br><span class="line">  this.el = null;</span><br><span class="line">&#125;</span><br><span class="line">News.prototype = &#123;</span><br><span class="line">  init: function()&#123;</span><br><span class="line">    throw new error(&quot;请重写你的方法&quot;)</span><br><span class="line">  &#125;,</span><br><span class="line">  add: function()&#123;</span><br><span class="line">    throw new error(&quot;请重写你的方法&quot;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getElement: function()&#123;</span><br><span class="line">    throw new error(&quot;请重写你的方法&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义好这个接口虚拟父类，我们就可以实现所有子类了，组合模式不仅仅是单层次组合，也可以是多层次的组合，我们可以将组合后的整体作为一个部分，继续组合。</p>
<h4 id="组合要有容器类"><a href="#组合要有容器类" class="headerlink" title="组合要有容器类"></a>组合要有容器类</h4><p>在组合模式中用到了继承，所以我们要把以前学过的继承相关知识拿出来用在组合模式中，比如寄生组合式继承，像下面这样显现新闻模块容器类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// 容器类构造函数</span><br><span class="line">var Container = function(id, parent)&#123;</span><br><span class="line">  News.call(this)</span><br><span class="line">  this.id = id</span><br><span class="line">  this.parent = parent</span><br><span class="line">  // 构建方法</span><br><span class="line">  this.init()</span><br><span class="line">&#125;</span><br><span class="line">// 寄生式继承父类原型方法</span><br><span class="line">var inheritPrototype = function(Sub,Sup)&#123;</span><br><span class="line">  var F = function()&#123;&#125;</span><br><span class="line">  F.prototype = new Sup()</span><br><span class="line">  F.constructor = F</span><br><span class="line">  Sub.prototype = new F()</span><br><span class="line">  Sub.constructor = Sub</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Container, NewS)</span><br><span class="line">// 构建方法</span><br><span class="line">Container.prototype.init = function()&#123;</span><br><span class="line">  this.el = document.createElement(&apos;ul&apos;)</span><br><span class="line">  this.el.id = this.id</span><br><span class="line">  this.el.className = &apos;new-container&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 添加子元素方法</span><br><span class="line">Container.prototype.add = function(child)&#123;</span><br><span class="line">  this.children.push(child)</span><br><span class="line">  this.el.appendChild(child.getElement())</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">// 获取当前元素方法</span><br><span class="line">Container.prototype.getElement = function()&#123;</span><br><span class="line">  return this.el</span><br><span class="line">&#125;</span><br><span class="line">// 显示方法</span><br><span class="line">Container.prototype.show = function()&#123;</span><br><span class="line">  this.parent.appendChild(this.el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同样下一层级的成员集合类以及后面的新闻组合体类实现的方法与之类似</span><br><span class="line"></span><br><span class="line">var Item = function(className)&#123;</span><br><span class="line">  News.call(this);</span><br><span class="line">  this.className = className || &quot;&quot;;</span><br><span class="line">  this.init()</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Container, NewS)</span><br><span class="line">Item.prototype.init = function()&#123;</span><br><span class="line">  this.el = doucment.createElement(&apos;li&apos;)</span><br><span class="line">  this.el.ckassName = this.className</span><br><span class="line">&#125;</span><br><span class="line">Item.prototype.add = function(child)&#123;</span><br><span class="line">  this.children.push(child)</span><br><span class="line">  this.el.appendChild(child.getElement())</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">Item.prototype.getElement = function()&#123;</span><br><span class="line">  return this.el</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var NewsGroup = function(className)&#123;</span><br><span class="line">  News.call(this);</span><br><span class="line">  this.className = className || &quot;&quot;;</span><br><span class="line">  this.init()</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Container, NewS)</span><br><span class="line">NewsGroup.prototype.init = function()&#123;</span><br><span class="line">  this.el = doucment.createElement(&apos;li&apos;)</span><br><span class="line">  this.el.ckassName = this.className</span><br><span class="line">&#125;</span><br><span class="line">NewsGroup.prototype.add = function(child)&#123;</span><br><span class="line">  this.children.push(child)</span><br><span class="line">  this.el.appendChild(child.getElement())</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">NewsGroup.prototype.getElement = function()&#123;</span><br><span class="line">  return this.el</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var news1 = new Container(&apos;news&apos;,document.body)</span><br><span class="line">news1.add(</span><br><span class="line">  new Item(&apos;normal&apos;).add(</span><br><span class="line">    new NewGroup(&apos;has-img&apos;)</span><br><span class="line">  )</span><br><span class="line">).show()</span><br></pre></td></tr></table></figure></p>
<p>类似这样，每创建一条新闻都是一个独立的个体，互不影响，避免相互间的耦合，也增强了组合后的模块的复杂性，类似的应用场景有表单的应用。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>组合模式能够给我们提供一个清晰的组成结构，组合对象类通过继承同一个父类使其具有统一的方法，这样也方便了我们统一管理与使用，当然此时单体成员与组合体成员行为表现就比较一致了，这也就模糊了简单对象与组合对象的区别。有时这也是一种对数据的分级式处理，清晰而又方便我们对数据的管理与使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/06/设计模式读书笔记(八)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/设计模式读书笔记(八)/" itemprop="url">设计模式读书笔记(八)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-06T23:29:11+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="城市间的公路-–-桥接模式"><a href="#城市间的公路-–-桥接模式" class="headerlink" title="城市间的公路 – 桥接模式"></a>城市间的公路 – 桥接模式</h3><p>桥接模式: 在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>场景如下： 当我们需要把页面上部的用户信息部分添加一些鼠标滑过特效，用户信息由很多小部件组成。对于用户名，鼠标划过直接改变北京色，但是像用户等级、用户消息这类部件只能改变里面的数字内容，处理的逻辑不太一样，所以写了不少代码，不过写完时，自己感觉很多是冗余的，却又不知道该如何改善。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var spans = document.getElementsByTagName(&apos;span&apos;)</span><br><span class="line">// 为用户名绑定特效</span><br><span class="line">spans[0].onmouseover = function()&#123;</span><br><span class="line">  this.style.color = &apos;red&apos;;</span><br><span class="line">  this.style.background =&apos;#ddd&apos;</span><br><span class="line">&#125;</span><br><span class="line">spans[1].onmouseover = function()&#123;</span><br><span class="line">  this.getElementsByTagName(&apos;strong&apos;)[0]/style.color = &apos;red&apos;</span><br><span class="line">  this.getElementsByTagName(&apos;strong&apos;)[0].style.background = &apos;#ddd&apos;</span><br><span class="line">&#125;</span><br><span class="line">spans[2].onmouseout = function()&#123;</span><br><span class="line">  this.getElementsByTagName(&apos;strong&apos;)[0].style.color = &apos;#333&apos;</span><br><span class="line">  this.getElementsByTagName(&apos;strong&apos;)[1].style.color = &apos;#f5f5f5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提取共同点"><a href="#提取共同点" class="headerlink" title="提取共同点"></a>提取共同点</h4><p>在上面，我们看到代码有很多看起来类似的地方，我在敲完这段代码的时候，都有不想写下去的感受了，是因为做了很多重复的事情，这时候，应该提取共同点，把逻辑相同的部分提取出来，这样代码也将会更简洁，重用率也会更大，当然可读性更高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 抽象</span><br><span class="line">function changeColor(dom,color,bg)&#123;</span><br><span class="line">  dom.style.color =color</span><br><span class="line">  dom.style.backround = bg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spans[0].onmouserout = function()&#123;</span><br><span class="line">  chageColor(this,&apos;#333&apos;,&apos;#f5f5f5&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多元化对象"><a href="#多元化对象" class="headerlink" title="多元化对象"></a>多元化对象</h4><p>桥接模式的强大之处对于多维的变化也很适用，比如我们书写一个canvas跑步游戏的时候，对于游戏中的人，小精灵，小球等一系列的实物都有动作单元，而他们的每个动作实现起来方式又是统一的，比如人和精灵和球的运动其实就是坐标位置x和y的变化，球的颜色与精灵的色彩绘制方式相似，这样我们可以将这些多维变化部分，提取出来作为一个抽象运动单元保存，而当我们创建实体时，将需要的每个抽象动作单元通过桥接，链接在一起运作。这样他们之间不会影响并且该方式降低了它们之间的耦合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 多维变量类</span><br><span class="line">// 运动单元</span><br><span class="line">function Speed(x,y)&#123;</span><br><span class="line">  this.x = x</span><br><span class="line">  this.y = y</span><br><span class="line">&#125;</span><br><span class="line">Speed.prototype.run = function()&#123;</span><br><span class="line">  console.log(&apos;运动起来&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 着色单元</span><br><span class="line">function Color(cl)&#123;</span><br><span class="line">  this.color = cl</span><br><span class="line">&#125;</span><br><span class="line">Color.prototype.draw = function()&#123;</span><br><span class="line">  console.log(&apos;绘制色彩&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 变形单元</span><br><span class="line">function Shape(sp)&#123;</span><br><span class="line">  this.shape = sp</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.change = function()&#123;</span><br><span class="line">  console.log(&apos;改变形状&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 说话单元</span><br><span class="line">function Speek(wd) &#123;</span><br><span class="line">  this.word = wd</span><br><span class="line">&#125;</span><br><span class="line">Speek.prototype.say = function()&#123;</span><br><span class="line">  console.log(&apos;书写字体)</span><br><span class="line">&#125;</span><br><span class="line">// 创建球类，并且可以为它着色，可以运动</span><br><span class="line"></span><br><span class="line">function Ball(x,y,c)&#123;</span><br><span class="line">  this.speed = new Speed(x,y)</span><br><span class="line">  this.color = new Color(c)</span><br><span class="line">&#125;</span><br><span class="line">Ball.prototype.init = function()&#123;</span><br><span class="line">  this.speed.run()</span><br><span class="line">  this.color.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同样我们可以创建一个人物类， 他可以运动也可以说话</span><br><span class="line">function People(x,y,f)&#123;</span><br><span class="line">  this.speed = new Speed(x,y)</span><br><span class="line">  this.font = new Speek(f)</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.init = function()&#123;</span><br><span class="line">  this.speed = new Speed(x,y)</span><br><span class="line">  this.font = new Speek(f)</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.init = function()&#123;</span><br><span class="line">  this.speed.run()</span><br><span class="line">  this.font.say()</span><br><span class="line">&#125;</span><br><span class="line">// 实现人物类</span><br><span class="line">var p = new People(10,20,16)</span><br><span class="line">p.init()</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>桥接模式最主要的特点是将实现层与抽象层解耦分离，使得两部分可以独立变化。由此可以看出，桥接模式主要是对结构之间的结构。而前面学习的抽象工厂与创建者模式主要业务是在于创建。通过桥接模式实现的解耦，使实现层与抽象层分开处理，避免需求的改变造成对象内部的修改，体现了面向对象拓展的开放及对想改的关闭原则。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/设计模式读书笔记(七)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/设计模式读书笔记(七)/" itemprop="url">设计模式读书笔记(七)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-27T22:14:35+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="装饰者模式-–-房子装修"><a href="#装饰者模式-–-房子装修" class="headerlink" title="装饰者模式 – 房子装修"></a>装饰者模式 – 房子装修</h3><p>装饰者模式：在不改变原对象的基础上，通过对其进行包装拓展（添加属性或者方法）使原有对象可以满足用户更复杂的需求。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>当用户表单需求发生改变，以前是当用户点击输入框时，如果输入框输入的内容有限制，那么其后面显示用户输入内容限制的文案格式的提示文案，现在多加一条，默认输入框上边显示一行提示文案，当用户点击输入框时文案消失</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 输入框元素</span><br><span class="line">var telInput = document.getElementById(&quot;tel_input&quot;)</span><br><span class="line">// 输入格式提示文案</span><br><span class="line">var telWarnText = doucment.getElementById(&quot;tel_warn_text&quot;)</span><br><span class="line">// 点击输入框显示输入框输入格式提示文案</span><br><span class="line">input.onclik = function()&#123;</span><br><span class="line">  telWarnText.style.display = &apos;inline-block&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 不加思索的添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 输入框元素</span><br><span class="line">var telInput = document.getElementById(&quot;tel_input&quot;)</span><br><span class="line">// 输入格式提示文案</span><br><span class="line">var telWarnText = doucment.getElementById(&quot;tel_warn_text&quot;)</span><br><span class="line">// 输入框提示输入文案</span><br><span class="line">var telDemoText = doucment.getElementById(&quot;tel_demo_text&quot;)</span><br><span class="line">// 点击输入框显示输入框输入格式提示文案并隐藏输入提示文案</span><br><span class="line">input.onclik = function()&#123;</span><br><span class="line">  telWarnText.style.display = &apos;inline-block&apos;</span><br><span class="line">  telDemoText.style.display = &apos;none&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是悲剧发生了，修改了一个电话输入框，后面还有姓名输入框，地址输入框，要在像电话输入框中一个一个这样查找功能代码，然后一个一个修改，这样真的好吗？<br>这里，装饰者模式就派上用场了</p>
<h4 id="装饰已有的房子"><a href="#装饰已有的房子" class="headerlink" title="装饰已有的房子"></a>装饰已有的房子</h4><p>装饰者模式，比如买一个新房子，你想住的更舒服，那么刚刚买的未装修过得房子住的就不舒服，就不能满足你的需求，那么要对其装修一番，放一个床，放一个桌子，摆上一张沙发，抬进来一个电视，这样就更舒服。同样，装饰者模式也是同样的道理，原有的功能已经不能满足用户的需求，此时你要做的是为原有功能添砖加瓦，设置新功能和属性来满足用户提出的需求。</p>
<p>首先明确原有的功能是什么，原有功能就是原来写的代码，要做的就是在原有功能的基础上增加新功能来满足用户提出的需求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 装饰者</span><br><span class="line">var decorator = function(input,fn)&#123;</span><br><span class="line">  // 事件源</span><br><span class="line">  var input =document.getElementById(input)</span><br><span class="line">  // 若事件源已经绑定方法</span><br><span class="line">  if(typeof input.onclick == &apos;function&apos;)&#123;</span><br><span class="line">    // 缓存事件源原有回调函数</span><br><span class="line">    var oldClick =input.onclick;</span><br><span class="line">    // 为事件源定义新的事件</span><br><span class="line">    input.onclick = function()&#123;</span><br><span class="line">      // 事件源原有的函数</span><br><span class="line">      oldClick()</span><br><span class="line">      // 新增加的函数</span><br><span class="line">      fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    input.onclick = fn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电话输入框功能装饰</span><br><span class="line">decorator(&apos;tel_input&apos;,function()&#123;</span><br><span class="line">  document.getElementById(&apos;tel_demo_text&apos;).style.display = &apos;none&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 姓名输入框功能装饰</span><br><span class="line">decorator(&apos;name_input&apos;,function()&#123;</span><br><span class="line">  document.getElementById(&apos;name_demo_text&apos;).style.display = &apos;none&apos;</span><br><span class="line">&#125;)</span><br><span class="line">//地址输入框功能装饰</span><br><span class="line">decorator(&apos;adress_input&apos;,function()&#123;</span><br><span class="line">  document.getElementById(&apos;adress_demo_text&apos;).style.display = &apos;none&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>通过这种方法，那么无论原来是否有绑定方法，都可以增添新功能<br>装饰者模式，就是在原有对象上进行属性和方法的添加</p>
<p>适配器模式也是对一个对象的装饰来适配其他对象，那么装饰者模式和适配器模式有什么不同呢？<br>适配器模式是对原有对象的适配，添加的方法与原有方法功能上大致相似，但是装饰者提供的方法与原来的方法功能上是有一定区别的，再者，使用适配器时我们新增的方法是要调用原来的方法，在装饰者模式中，是要调用原来的方法，而不需要了解原有对象有哪些功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/设计模式读书笔记(六)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/设计模式读书笔记(六)/" itemprop="url">设计模式读书笔记(六)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T23:29:53+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="代理模式-–-牛郎织女"><a href="#代理模式-–-牛郎织女" class="headerlink" title="代理模式 – 牛郎织女"></a>代理模式 – 牛郎织女</h3><p>代理模式：由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用。</p>
<p>由于用户相册模块上传的照片量越来越大，导致不得不把照片重新部署在另一个域（可以理解为另一台服务器），这样对于前端来说，用户上传图片的请求路径发生变化，指向其他服务器，这就导致了跨域问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 当前域 www.xx.com</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url : &apos;http://upload.xx.com/upload.php&apos;,</span><br><span class="line">  success:function(data)&#123;</span><br><span class="line">    // 无法获取返回值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这一切只是因为跨域，浏览器为了保证安全，不允许跨域调用其他页面的资源，资源就包括操作DOM，图片，js，css等, javaScript还对同一域名不同的端口号，同一域名不同的协议，域名和域名对应的IP，主域与子域，子域与子域等做了限制，都不能直接调用。</p>
<h4 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下"></a>示例如下</h4><p>同一域名不同的端口号： <a href="http://www.baidu.com:8080" target="_blank" rel="noopener">http://www.baidu.com:8080</a> <a href="http://www.baidu.com:8081" target="_blank" rel="noopener">http://www.baidu.com:8081</a><br>同一域名不同的协议: <a href="http://wwww.baidu.com" target="_blank" rel="noopener">http://wwww.baidu.com</a> <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a><br>域名与域名对应的IP： <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> <a href="http://61.135.169.125" target="_blank" rel="noopener">http://61.135.169.125</a><br>主域与子域 ： <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> <a href="http://b.baidu.com" target="_blank" rel="noopener">http://b.baidu.com</a><br>子域与子域： <a href="http://tieba.baidu.com" target="_blank" rel="noopener">http://tieba.baidu.com</a> <a href="http://kongjian.baidu.com" target="_blank" rel="noopener">http://kongjian.baidu.com</a></p>
<p>那么既然这样，相册页面还能与子域的图片上传模块所在的服务器进行通信吗？<br>其实，相册页面与图片上传模块所在的服务器之间可抽象成两个对象，那么现在的问题是，他们被一条河隔开了，就像天河的牛郎织女，只能远远相望，同样，想让跨域两端的对象之间实现通信，就需要找个代理对象来实现他们之间的通信。</p>
<p>当然，代理对象有很多，简单一点的如img之类的标签通过src属性可以向其他域下的服务器发送请求，不过这类请求是get请求，并且是单向的，它不会有响应数据，就好比你站在河的一边向另一边发送消息，又不想让别人听到看到，你将写好信息的纸放在口袋里，然后扔过去，不过河对岸有没有收到你的消息就不知道了，比如，站长平台就会对你操作页面的信息通过img标签发送get请求，他们统计的情况，你就不知道了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Count = (function()&#123;</span><br><span class="line">  var img = new Image()</span><br><span class="line">  // 返回统计函数</span><br><span class="line">  return function(param)&#123;</span><br><span class="line">    var src = &apos;http://www.count.com/a.gif?&apos;</span><br><span class="line">    // 拼接字符串请求</span><br><span class="line">    for(var i in param)&#123;</span><br><span class="line">      str += i + &apos;=&apos; +param[i]</span><br><span class="line">    &#125;</span><br><span class="line">    // 发送请求</span><br><span class="line">    img.src = str</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>第二种代理对象形式是通过script标签,比如我们在CDN（内容分发网络，一种更接近用户的网络架构，是用户可以就近获取内容）上更快速的获得jQuery文件时，用<br>“<srcipt src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></srcipt>“来获取，然而这种获取方式获取到的script内容是不变的，而我们需要的代理对象，是对页面与浏览器间通信的，显然，上面的方式还不能满足我们的需求，我们需要的代理对象是能够相互通信的，不过我们知道通过src属性可实现get请求，因此我们可以在src指向的url（请求地址）上面添加一些字段信息，然后服务器端获取这些字段，再相应的生成一份内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function jsonpCallBack(res,req)&#123;</span><br><span class="line">  console.log(res,req)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://localhost/test/jsonp.php?callback=jsonpCallBack&amp;data=getJsonData&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 另外一个域下服务器请求接口</span><br><span class="line">&lt;?php</span><br><span class="line">  $data = $_GET[&quot;data&quot;]</span><br><span class="line">  $callback = $_GET[&quot;callback&quot;]</span><br><span class="line">  echo $callback.&quot;(&apos;success&apos;,&apos;&quot;.data.&quot;&apos;)&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式也被称作为JSONP方式，有时候我们还会通过一个方法来动态生成需要的JSONP中的<script>标签</p>
<h4 id="代理模板"><a href="#代理模板" class="headerlink" title="代理模板"></a>代理模板</h4><p>与之类似的还有另外一种方案是被称为代理模板的方案，既然不同域之间相互调用对方的页面资源是有限制的，自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理页面A中的对象的方式是可以的。那么要实现这种方式，我们只需要在被访问的域中，请求返回的HEADER重定向到代理页面，并在代理页面处理被代理页面A就可以了。<br>既然是这样的话，那么我们在自己的域中要有A，B两个页面了<br>比如：我们将自己的域称为X域，另外的域称为Y域，X域中要有一个被代理页面，即A页面。在A页面中应该具备三个部分，第一个部分是发送请求的模块，如form表单提交，负责向Y域发送请求，并提供额外两组数据，其一是要执行的回调函数名称，其二是X域中代理模板所在的路径，并将target目标指向内嵌框架。第二个部分是一个内嵌框架，如iframe，负责提供第一个部分中form表单的响应目标target的指向，并将嵌入X域中的代理页面作为子页面，即B页面。第三个部分是 一个回调函数，负责处理发返回的数据。</p>
<p>代理模板的知识，在跨域资源中尤为明显，后续将专门展开关于跨域的知识详解，现在不做展开，等完成这个设计模式系列再详细写出关于跨域的解决方案。</p>
</script></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/设计模式读书笔记(五)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/设计模式读书笔记(五)/" itemprop="url">设计模式读书笔记(五)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-19T22:57:39+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h3><p>惰性单例: 单例对象的延迟创建就叫做惰性单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var LazySingle = function()&#123;</span><br><span class="line">  var _instance = null;</span><br><span class="line">  function Single()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      pubMethod: function()&#123;&#125;,</span><br><span class="line">      publicPro: &apos;1.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!_instance)&#123;</span><br><span class="line">      _instance = Single()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return _instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p>结构型设计模式关注于如何将类或者对象组合成更大，更复杂的结构，以简化设计。</p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 外观模式实现</span><br><span class="line">function addEvent(dom, type, fn)&#123;</span><br><span class="line">    if(dom.addEventListener)&#123;</span><br><span class="line">      dom.addEventListener(type,fn,false)</span><br><span class="line">    &#125;else if(dom.attachEvent)&#123;</span><br><span class="line">      dom.attachEvent(&apos;on&apos;+type,fn)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      dom[&apos;on&apos;+type] = fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="适配器模式-–-水管弯弯"><a href="#适配器模式-–-水管弯弯" class="headerlink" title="适配器模式 – 水管弯弯"></a>适配器模式 – 水管弯弯</h4><p>适配器模式： 将一个类(对象)的接口(方法或属性)转化成另一个接口,以满足用户需求，使类(对象)之间接口的不兼容通过适配器得以解决，运用场景有数据适配，方法适配等</p>
<h4 id="适配异类框架"><a href="#适配异类框架" class="headerlink" title="适配异类框架"></a>适配异类框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 定义框架</span><br><span class="line">var A = A || &#123;&#125;</span><br><span class="line">// 通过ID获取元素</span><br><span class="line">A.g = function(id)&#123;</span><br><span class="line">  return document.getElementById(id)</span><br><span class="line">&#125;</span><br><span class="line">// 为元素绑定事件</span><br><span class="line">A.on = function(id, type, fn)&#123;</span><br><span class="line">  // 如果传递参数是字符串则以id处理，否则以元素对象处理</span><br><span class="line">  var dom = typeof id == &apos;String&apos; ? this.g(id) : id</span><br><span class="line">  if(dom.addEventListener) &#123;</span><br><span class="line">    dom.addEventListener(type, fn, false);</span><br><span class="line">    // DOM2</span><br><span class="line">  &#125;else if(dom.attachEvent)&#123;</span><br><span class="line">    dom.attachEvent(&apos;on&apos; + type ,fn)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    dom(&apos;on&apos; + type) = fn</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想引用jQuery来换原有的A库，那么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A.g = function(id)&#123;</span><br><span class="line">  return $(id).get(0)</span><br><span class="line">&#125;</span><br><span class="line">A.on = function(id, type, fn)&#123;</span><br><span class="line">  var dom = typeof id == &apos;String&apos; ? $(&apos;#&apos;+id) : $(id)</span><br><span class="line">  dom.on(type,fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="参数适配器"><a href="#参数适配器" class="headerlink" title="参数适配器"></a>参数适配器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing(name,titile,age,color,size,prize)&#123;&#125;</span><br><span class="line"></span><br><span class="line">function doSomeThing(onj)&#123;</span><br><span class="line">  var _adapter = &#123;</span><br><span class="line">    name:&apos;mr&apos;,</span><br><span class="line">    titile:&apos;设计模式&apos;</span><br><span class="line">    age: 26,</span><br><span class="line">    color:&apos;pink&apos;,</span><br><span class="line">    size:100,</span><br><span class="line">    prize:50</span><br><span class="line">  &#125;</span><br><span class="line">  for(var i in _addpter)&#123;</span><br><span class="line">    _adapter[i] = obj[i] || _adapter[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据适配"><a href="#数据适配" class="headerlink" title="数据适配"></a>数据适配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;JavaScript&apos;,&apos;book&apos;,&apos;前端编程语言&apos;,&apos;8.1&apos;]</span><br><span class="line"></span><br><span class="line">// 我们发现数组中的每个成员代表的意义不同，所以这种数据结构语义不好，我们通常会将其适配成对象形式，比如下面这种对象数据结构</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name:&apos;&apos;,</span><br><span class="line">  type:&apos;&apos;,</span><br><span class="line">  title:&apos;&apos;,</span><br><span class="line">  time:&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们可以像下面这样适配</span><br><span class="line">function arrToObjAdapter(arr)&#123;</span><br><span class="line"> var _obj = &#123; </span><br><span class="line">  name:&apos;&apos;,</span><br><span class="line">  type:&apos;&apos;,</span><br><span class="line">  title:&apos;&apos;,</span><br><span class="line">  time:&apos;&apos;</span><br><span class="line">  &#125;</span><br><span class="line"> arr.map(function(item,index)&#123;</span><br><span class="line">   Object.keys(_obj).forEach(function(key,_index)&#123;</span><br><span class="line">     if(index == _index)&#123;</span><br><span class="line">       _obj[key] = item</span><br><span class="line">     &#125;   </span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"> return _obj</span><br><span class="line">&#125;</span><br><span class="line">arrToObjAdapter(arr) // &#123;name: &quot;JavaScript&quot;, type: &quot;book&quot;, title: &quot;前端编程语言&quot;, time: &quot;8.1&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务器端数据适配"><a href="#服务器端数据适配" class="headerlink" title="服务器端数据适配"></a>服务器端数据适配</h4><p>前端程序不再为后端传递的数据所束缚，如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 简化模型，这里使用了jQuery的ajax方法，理想数据是一个一维数组</span><br><span class="line">function ajaxAdpter(data)&#123;</span><br><span class="line">  return [data[&apos;key1&apos;],data[&apos;key2&apos;],data[&apos;key3&apos;]]</span><br><span class="line">&#125;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:&apos;someAdress.php&apos;,</span><br><span class="line">  success:function(data,status)&#123;</span><br><span class="line">    if(data)&#123;</span><br><span class="line">      // 使用适配后的数据-- 返回的对象</span><br><span class="line">      doSomething(ajaxAdpter(data))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>像这样，如果日后后端数据有任何变化我们只需相应地更改ajaxAdapter 适配器的数据格式就行了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/18/设计模式读书笔记(四)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/设计模式读书笔记(四)/" itemprop="url">设计模式读书笔记(四)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-18T22:38:05+08:00">
                2018-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>设计模式能够保证我们以优雅的方式组织我们的代码，通过学习掌握，能够写出漂亮，具有结构性和组织性的代码。
</code></pre><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。</p>
<h3 id="分即是合–建造者模式"><a href="#分即是合–建造者模式" class="headerlink" title="分即是合–建造者模式"></a>分即是合–建造者模式</h3><p>建造者模式：将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。</p>
<h3 id="建造者模式与工厂模式的区别"><a href="#建造者模式与工厂模式的区别" class="headerlink" title="建造者模式与工厂模式的区别"></a>建造者模式与工厂模式的区别</h3><p>1.工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建的是什么)。不关心创建的整个过程。<br>2.建造者模式在创建对象时更为复杂，虽然其目的也是为了创建对象，但是更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 创建一位人类</span><br><span class="line">var Human = function(param)&#123;</span><br><span class="line">  this.skill = param &amp;&amp; param.skill || &quot;保密&quot;</span><br><span class="line">  this.hobby = param &amp;&amp; param.hobby || &quot;保密&quot;</span><br><span class="line">&#125;</span><br><span class="line">Human.prototype = function()&#123;</span><br><span class="line">  getSkill: function()&#123;</span><br><span class="line">    return this.skill</span><br><span class="line">  &#125;,</span><br><span class="line">  getHobby: function()&#123;</span><br><span class="line">    return this.hobby</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化姓名类</span><br><span class="line">var Named = function()&#123;</span><br><span class="line">  var that = this</span><br><span class="line">  (function(name, that)&#123;</span><br><span class="line">    that.wholeName = name</span><br><span class="line">    if(name.indexOf(&quot; &quot;) &gt; -1)&#123;</span><br><span class="line">      that.FirstName = name.slice(0, name.indexOf(&quot; &quot;))</span><br><span class="line">      that.SecondName = name.slice(name.indexOf(&quot; &quot;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(name, that)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化职业类</span><br><span class="line">var Work = function()&#123;</span><br><span class="line">  var this = that</span><br><span class="line">  (function(work, that)&#123;</span><br><span class="line">    swicth(work)&#123;</span><br><span class="line">      case &quot;code&quot; :</span><br><span class="line">        that.work = &quot;工程师&quot;</span><br><span class="line">        that.workDescript = &quot;每天沉醉于编程&quot;</span><br><span class="line">        break;</span><br><span class="line">      case &quot;UI&quot; :</span><br><span class="line">        that.work = &quot;设计师&quot;</span><br><span class="line">        that.workDescript = &quot;设计更是一种艺术&quot;</span><br><span class="line">        break;</span><br><span class="line">      case &quot;teach&quot; :</span><br><span class="line">        that.work = &quot;教师&quot;</span><br><span class="line">        that.workDescript = &quot;分享也是一种快乐&quot;</span><br><span class="line">        break;</span><br><span class="line">     default: </span><br><span class="line">        that.work = work;</span><br><span class="line">        that.workDescript = &quot;对不起，我们还不清楚您所选择职位的描述&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(work, that)</span><br><span class="line">&#125;</span><br><span class="line">Work.prototype.changeWork = function(work)&#123;</span><br><span class="line">    this.work = work</span><br><span class="line">&#125;</span><br><span class="line">Work.prototype.changeDescript = function(descript)&#123;</span><br><span class="line">    this.workDescript = descript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就创建出3个类别来了–应聘者类，名字解析类，期望工作类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  应聘者建造者</span><br><span class="line">  参数 name</span><br><span class="line">  参数 work</span><br><span class="line">*/</span><br><span class="line">var Person = function(name,work)&#123;</span><br><span class="line">  var _person = new Human()</span><br><span class="line">  _person.name = new Named(name)</span><br><span class="line">  _person.work = new Work(work)</span><br><span class="line">  return _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;xiao ming&apos;,&apos;code&apos;)</span><br><span class="line">console.log(person.skill)</span><br><span class="line">console.log(person.name.FirstName)</span><br><span class="line">console.log(person.work.work)</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建者模式创建的类更为复杂，也可以说这种模式创建的对象是一个复合对象，这种模式无形中增加了结构的复杂性，如果对象的细粒度很小、复用性很低、变化程度不大的情况下，我们还是应该采用创建一个整体的形式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/设计模式读书笔记(三)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/设计模式读书笔记(三)/" itemprop="url">设计模式读书笔记(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-17T23:50:57+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>设计模式能够保证我们以优雅的方式组织我们的代码，通过学习掌握，能够写出漂亮，具有结构性和组织性的代码。
</code></pre><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>创建型设计模式是一类处理对象创建的设计模式，通过某种方法控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。</p>
<h3 id="带头模范–抽象类"><a href="#带头模范–抽象类" class="headerlink" title="带头模范–抽象类"></a>带头模范–抽象类</h3><p>抽象类：定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Car = function()&#123;&#125;</span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  getPrice: function()&#123;</span><br><span class="line">    return new Error(&quot;抽象方法不能调用&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  getSpeed: function()&#123;</span><br><span class="line">    return new Error(&quot;抽象方法不能调用&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="幽灵工厂-–-抽象工厂模式"><a href="#幽灵工厂-–-抽象工厂模式" class="headerlink" title="幽灵工厂 – 抽象工厂模式"></a>幽灵工厂 – 抽象工厂模式</h4><p>抽象工厂模式： 抽象类中定义的方法只是显性的指明一些方法，但没有具体的功能实现，具体实现是在对象中，而抽象工厂模式创造出来的也是抽象类，不能创建一个具体的实现类，所以，一般把起作为父类来创建子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂方法</span><br><span class="line">var VehicleFactory = function(subType, superType)&#123;</span><br><span class="line">  // 判断抽象工厂中是否有该抽象类</span><br><span class="line">  if(typeof VehicleFactory[superType] == &quot;function&quot;)&#123;</span><br><span class="line">    // 缓存类</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = new VehicleFactory[superType]()</span><br><span class="line">    // 将子类的constructor指向子类</span><br><span class="line">    subType.constructor = subType</span><br><span class="line">    subType.prototype = new F()</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    throw new Error(&quot;未创建抽象类&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VehicleFactory.Car = function()&#123;</span><br><span class="line">  this.type = &apos;car&apos;</span><br><span class="line">&#125;</span><br><span class="line">VehicleFactory.Car.prototype = &#123;</span><br><span class="line">  getPrice: function()&#123;</span><br><span class="line">    return new Error(&quot;抽象方法不能调用&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  getSpeed: function()&#123;</span><br><span class="line">    return new Error(&quot;抽象方法不能调用&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VehicleFactory.Bus = function()&#123;</span><br><span class="line">  this.type = &apos;bar&apos;</span><br><span class="line">&#125;</span><br><span class="line">VehicleFactory.Bus.prototype = &#123;</span><br><span class="line">  getPrice: function()&#123;</span><br><span class="line">    return new Error(&quot;抽象方法不能调用&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  getSpeed: function()&#123;</span><br><span class="line">    return new Error(&quot;抽象方法不能调用&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了抽象工厂类后， 我们就可以具体的实现了</p>
<pre><code>// 宝马
var BWM = function(price, speed){
  this.price = price;
  this.speed = speed
}
VehicleFactory(BWM , &quot;Car&quot;)
BWM.prototype = {
  getPrice: function(){
    return this.price;
  },
  getSpeed: function(){
    return this.speed;
  }
}

// 兰博基尼
var Lamborghini = function(price, speed){
  this.price = price;
  this.speed = speed
}
VehicleFactory(Lamborghini , &quot;Car&quot;)
Lamborghini.prototype = {
  getPrice: function(){
    return this.price;
  },
  getSpeed: function(){
    return this.speed;
  }
}
... ...
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象工厂模式是设计模式中最抽象的一种设计模式，也是创建模式中唯一一种抽象化创建模式，该模式创建出的结果不是一个真实的对象实例，而是一个类簇，它制定了类的结构，这也就是区别于简单工厂模式创建单一对象，工厂方法模式创建多类对象.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
